import fetch from 'node-fetch';
import { ProjectData, GeneratedReadme } from '../types';

export class GeminiService {
  private apiKey: string;
  private readonly apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async generateReadme(projectData: ProjectData): Promise<GeneratedReadme> {
    const prompt = this.buildPrompt(projectData);

    const response = await fetch(`${this.apiUrl}?key=${this.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 8000,
        }
      })
    });

    if (!response.ok) {
      const errorData: any = await response.json();
      throw new Error(`Gemini API error: ${errorData.error?.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const content = data.candidates?.[0]?.content?.parts?.[0]?.text || '';

    if (!content) {
      throw new Error('No content generated by Gemini API');
    }

    const cleanedContent = this.cleanupGeneratedContent(content);
    return {
      content: cleanedContent,
      sections: this.extractSections(cleanedContent)
    };
  }

  private buildPrompt(projectData: ProjectData): string {
    const techStack = this.detectTechStack(projectData);
    const projectType = this.detectProjectType(projectData);
    
    const fileContents = projectData.files
      .filter(file => file.content && file.type === 'file' && file.content.length > 10)
      .slice(0, 15)
      .map(file => `File: ${file.path}\n${file.content.slice(0, 2000)}`)
      .join('\n\n---\n\n');

    return `You are an expert technical writer creating a professional README.md for a local project directory.

PROJECT DETAILS:
Name: ${projectData.name}
Description: ${projectData.description || 'No description provided'}
Primary Language: ${projectData.language || 'Not specified'}
Version: ${projectData.version || '1.0.0'}
Tech Stack: ${techStack}
Project Type: ${projectType}
Files: ${projectData.structure.files} files across ${projectData.structure.directories} directories

KEY FILES CONTENT:
${fileContents}

Generate a comprehensive, professional README.md using ONLY pure markdown syntax (NO HTML tags).

STRUCTURE:
# ${projectData.name}

> **${this.generateTagline(projectData, projectType)}**

${projectData.description || `A ${projectData.language} project built with modern best practices`}

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Version](https://img.shields.io/badge/version-${projectData.version || '1.0.0'}-green.svg)]()

## ✨ Features

${this.generateFeatures(projectType)}

## 🚀 Quick Start

### Prerequisites
${this.generatePrerequisites(projectData)}

### Installation
\`\`\`bash
${this.generateInstallCommands(projectData)}
\`\`\`

### Usage
${this.generateUsageExample(projectData, projectType)}

## 📁 Project Structure
\`\`\`
${this.generateProjectStructure(projectData)}
\`\`\`

## 🛠️ Tech Stack
${this.generateTechStackDetails(techStack)}

## 📚 Documentation
- [Getting Started](#-quick-start)
- [Configuration](#configuration)
- [API Reference](#api-reference)
- [Examples](#examples)

## 🤝 Contributing
1. Fork the repository
2. Create your feature branch (\`git checkout -b feature/amazing-feature\`)
3. Commit your changes (\`git commit -m 'Add amazing feature'\`)
4. Push to the branch (\`git push origin feature/amazing-feature\`)
5. Open a Pull Request

## 📄 License
This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments
- Built with ${projectData.language}
- Thanks to all contributors
- Inspired by modern development practices

---
Made with ❤️ by the ${projectData.name} team

REQUIREMENTS:
- Use ONLY markdown syntax (no HTML)
- Make it comprehensive but scannable
- Include proper code formatting
- Use emojis for visual appeal
- Focus on clarity and professionalism
- Ensure GitHub compatibility`;
  }

  private generateTagline(projectData: ProjectData, projectType: string): string {
    const taglines = {
      'Frontend Application': `🚀 Modern ${projectData.language} application with sleek UI/UX`,
      'Backend API': `⚡ High-performance ${projectData.language} API built for scale`,
      'Full-Stack Application': `🔥 Complete full-stack solution powered by ${projectData.language}`,
      'CLI Tool': `🛠️ Powerful command-line tool for developers`,
      'Library': `📚 Essential ${projectData.language} library for modern development`,
      'Python Application': `🐍 Robust Python application with enterprise features`,
      'JavaScript/Node.js Project': `⚡ Modern JavaScript solution for the web`,
      'default': `💎 Professional ${projectData.language} project`
    };

    return taglines[projectType] || taglines.default;
  }

  private generateFeatures(projectType: string): string {
    const features = {
      'Frontend Application': `- 🎨 Modern, responsive design
- ⚡ Optimized performance
- 📱 Mobile-first approach
- 🔧 Easy customization
- 🌐 Cross-browser compatibility`,
      'Backend API': `- 🔄 RESTful API endpoints
- 🔒 Secure authentication
- 📊 Built-in monitoring
- 🚀 Scalable architecture
- 📝 Auto-generated documentation`,
      'CLI Tool': `- ⚡ Fast execution
- 🎯 Intuitive commands
- 📁 File system integration
- 🔧 Configurable options
- 💻 Cross-platform support`,
      'default': `- ✨ Clean, modern architecture
- 🚀 High performance
- 🔧 Easy to extend
- 📚 Well documented
- 🧪 Thoroughly tested`
    };

    return features[projectType] || features.default;
  }

  private generatePrerequisites(projectData: ProjectData): string {
    if (projectData.files.some(f => f.name === 'package.json')) {
      return `- Node.js (v16 or higher)
- npm or yarn package manager
- Git for version control`;
    }
    if (projectData.files.some(f => f.name === 'requirements.txt')) {
      return `- Python 3.8 or higher
- pip package manager
- Virtual environment (recommended)`;
    }
    if (projectData.files.some(f => f.name === 'Cargo.toml')) {
      return `- Rust (latest stable version)
- Cargo package manager`;
    }
    return `- Git for version control
- Your favorite code editor
- Terminal/command line interface`;
  }

  private generateInstallCommands(projectData: ProjectData): string {
    if (projectData.files.some(f => f.name === 'package.json')) {
      return `# Clone the repository
git clone <repository-url>
cd ${projectData.name}

# Install dependencies
npm install

# Start development server
npm run dev`;
    }
    if (projectData.files.some(f => f.name === 'requirements.txt')) {
      return `# Clone the repository
git clone <repository-url>
cd ${projectData.name}

# Create virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\\Scripts\\activate

# Install dependencies
pip install -r requirements.txt

# Run the application
python main.py`;
    }
    return `# Clone the repository
git clone <repository-url>
cd ${projectData.name}

# Follow language-specific setup instructions`;
  }

  private generateUsageExample(projectData: ProjectData, projectType: string): string {
    if (projectType === 'CLI Tool') {
      return `\`\`\`bash
# Basic usage
${projectData.name} --help

# Run with options
${projectData.name} --config config.json
\`\`\``;
    }
    return `\`\`\`bash
# Start the application
npm start

# Or for development
npm run dev
\`\`\``;
  }

  private generateProjectStructure(projectData: ProjectData): string {
    const structure = projectData.files
      .filter(f => f.type === 'directory' || this.isImportantFile(f.name))
      .slice(0, 20)
      .map(f => {
        const indent = f.path.split('/').length - 1;
        const prefix = '  '.repeat(indent);
        const icon = f.type === 'directory' ? '📁' : '📄';
        return `${prefix}${icon} ${f.name}`;
      })
      .join('\n');

    return structure || `📁 ${projectData.name}/
  📄 README.md
  📄 package.json
  📁 src/
    📄 index.js`;
  }

  private generateTechStackDetails(techStack: string): string {
    return `**Core Technologies:**
${techStack.split(', ').map(tech => `- ${tech}`).join('\n')}

**Development Tools:**
- Version Control: Git
- Code Quality: ESLint, Prettier
- Testing: Jest, Testing Library
- Documentation: README, JSDoc`;
  }

  private detectTechStack(projectData: ProjectData): string {
    const techStack: string[] = [];
    
    const packageJson = projectData.files.find(f => f.name === 'package.json');
    if (packageJson?.content) {
      try {
        const pkg = JSON.parse(packageJson.content);
        const deps = { ...pkg.dependencies, ...pkg.devDependencies };
        
        if (deps.react) techStack.push('React');
        if (deps.vue) techStack.push('Vue.js');
        if (deps.angular) techStack.push('Angular');
        if (deps.next) techStack.push('Next.js');
        if (deps.express) techStack.push('Express.js');
        if (deps.typescript) techStack.push('TypeScript');
        if (deps.tailwindcss) techStack.push('Tailwind CSS');
        if (deps.sass) techStack.push('Sass');
        if (deps.webpack) techStack.push('Webpack');
        if (deps.vite) techStack.push('Vite');
      } catch (error) {
        // Ignore parse errors
      }
    }

    if (projectData.files.some(f => f.name === 'requirements.txt')) techStack.push('Python');
    if (projectData.files.some(f => f.name === 'Cargo.toml')) techStack.push('Rust');
    if (projectData.files.some(f => f.name === 'go.mod')) techStack.push('Go');
    if (projectData.files.some(f => f.name === 'Dockerfile')) techStack.push('Docker');

    return techStack.length > 0 ? techStack.join(', ') : projectData.language || 'Various Technologies';
  }

  private detectProjectType(projectData: ProjectData): string {
    const packageJson = projectData.files.find(f => f.name === 'package.json');
    if (packageJson?.content) {
      try {
        const pkg = JSON.parse(packageJson.content);
        const deps = { ...pkg.dependencies, ...pkg.devDependencies };
        
        if (deps.react || deps.vue || deps.angular) return 'Frontend Application';
        if (deps.next || deps.nuxt || deps.gatsby) return 'Full-Stack Application';
        if (deps.express || deps.fastify || deps.koa) return 'Backend API';
        if (pkg.bin) return 'CLI Tool';
        if (pkg.main && !deps.express) return 'Library';
      } catch (error) {
        // Ignore parse errors
      }
    }

    if (projectData.files.some(f => f.name === 'requirements.txt')) return 'Python Application';
    if (projectData.files.some(f => f.name === 'Cargo.toml')) return 'Rust Application';
    if (projectData.files.some(f => f.name === 'go.mod')) return 'Go Application';

    return 'Software Project';
  }

  private isImportantFile(fileName: string): boolean {
    const important = [
      'package.json', 'tsconfig.json', 'next.config.js', 'vite.config.js',
      'requirements.txt', 'setup.py', 'Cargo.toml', 'go.mod', 'Dockerfile',
      'README.md', 'LICENSE', '.env.example', 'config.js', 'index.js', 'main.py'
    ];
    return important.includes(fileName);
  }

  private cleanupGeneratedContent(content: string): string {
    return content
      .replace(/^```markdown\s*\n/, '')
      .replace(/\n```$/, '')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  }

  private extractSections(content: string): string[] {
    const sections: string[] = [];
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('# ') || trimmedLine.startsWith('## ')) {
        const sectionName = trimmedLine.replace(/^#+\s*/, '').replace(/[^\w\s]/g, '').trim();
        if (sectionName) {
          sections.push(sectionName);
        }
      }
    }

    return sections;
  }
}