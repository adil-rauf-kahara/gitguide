import { Repository, GeneratedReadme } from '../types';

export class GeminiService {
  private apiKey: string;
  
  constructor() {
    this.apiKey = import.meta.env.VITE_GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('Gemini API key not found. Please add VITE_GEMINI_API_KEY to your environment variables.');
    }
  }

  async generateReadme(repository: Repository): Promise<GeneratedReadme> {
    const prompt = this.buildPrompt(repository);
    
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${this.apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 8000,
        }
      })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Gemini API error: ${error.error?.message || 'Unknown error'}`);
    }

    const data = await response.json();
    const content = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
    if (!content) {
      throw new Error('No content generated by Gemini API');
    }

    // Clean up the generated content
    const cleanedContent = this.cleanupGeneratedContent(content);

    return {
      content: cleanedContent,
      sections: this.extractSections(cleanedContent)
    };
  }

  private buildPrompt(repository: Repository): string {
    const techStack = this.detectTechStack(repository);
    const projectType = this.detectProjectType(repository);
    const logoFiles = this.findBestLogo(repository);
    const demoFiles = this.findDemoFiles(repository);
    
    const fileContents = repository.files
      .filter(file => file.content && file.type === 'file')
      .slice(0, 12) // Analyze more files for better context
      .map(file => `File: ${file.path}\n${file.content.slice(0, 2500)}`)
      .join('\n\n---\n\n');

    const repoUrl = `https://github.com/${repository.owner}/${repository.name}`;
    const logoUrl = logoFiles.length > 0 ? `https://raw.githubusercontent.com/${repository.owner}/${repository.name}/main/${logoFiles[0].path}` : '';

    return `You are an expert technical writer and UI/UX designer creating a stunning, professional README.md that rivals the best open-source projects on GitHub (like Vercel, Supabase, Tailwind CSS, React, and Next.js).

REPOSITORY DETAILS:
- Name: ${repository.name}
- Description: ${repository.description || 'No description provided'}
- Primary Language: ${repository.language || 'Not specified'}
- Owner: ${repository.owner}
- Repository URL: ${repoUrl}
- Stars: ${repository.stars}
- Forks: ${repository.forks}
- Tech Stack: ${techStack}
- Project Type: ${projectType}
${logoUrl ? `- Logo URL: ${logoUrl}` : ''}
${demoFiles.length > 0 ? `- Demo Files Available: ${demoFiles.map(f => f.path).join(', ')}` : ''}

KEY FILES CONTENT:
${fileContents}

CRITICAL REQUIREMENTS:
1. Generate ONLY clean, valid markdown - NO HTML tags whatsoever
2. Use pure markdown syntax for all formatting
3. Create a visually stunning, professional README using only markdown
4. Use strategic emojis and badges for visual appeal
5. Focus on clarity, usability, and GitHub-native rendering
6. Make it comprehensive but scannable
7. Follow industry best practices from top open-source projects

GENERATE A CLEAN MARKDOWN README WITH THIS STRUCTURE:

${logoUrl ? `![${repository.name} Logo](${logoUrl})` : ''}

# ${repository.name}

> **${this.generateTagline(repository, projectType)}**

${repository.description || `A powerful ${repository.language} project built for modern developers`}

[![GitHub Stars](https://img.shields.io/github/stars/${repository.owner}/${repository.name}?style=for-the-badge&logo=github&color=FFD700&labelColor=black)](${repoUrl})
[![GitHub Forks](https://img.shields.io/github/forks/${repository.owner}/${repository.name}?style=for-the-badge&logo=github&color=blue&labelColor=black)](${repoUrl}/fork)
[![License](https://img.shields.io/github/license/${repository.owner}/${repository.name}?style=for-the-badge&color=green&labelColor=black)](${repoUrl}/blob/main/LICENSE)
[![Issues](https://img.shields.io/github/issues/${repository.owner}/${repository.name}?style=for-the-badge&color=red&labelColor=black)](${repoUrl}/issues)

**[ðŸ“¸ View Demo](${repoUrl}) â€¢ [ðŸš€ Get Started](#-quick-start) â€¢ [ðŸ“š Documentation](#-documentation) â€¢ [ðŸ’¬ Community](#-community)**

---

## ðŸŒŸ What Makes ${repository.name} Special?

> **Transform your workflow with ${repository.name}** â€“ the next-generation solution that developers and teams trust worldwide.

${this.generateKeyBenefits(repository, projectType)}

## âœ¨ Features

### ðŸŽ¯ Core Features
${this.generateCoreFeatures(projectType)}

### âš¡ Advanced Capabilities  
${this.generateAdvancedFeatures(projectType)}

## ðŸŽ¬ Demo

${demoFiles.length > 0 ? 
  `![Demo Screenshot](https://raw.githubusercontent.com/${repository.owner}/${repository.name}/main/${demoFiles[0].path})` : 
  `![Demo Preview](https://via.placeholder.com/800x400/6366f1/ffffff?text=${encodeURIComponent(repository.name + ' Demo')})`
}

*ðŸŽ¥ Want to see more? Check out our [live examples](${repoUrl}) and [interactive demos](${repoUrl}).*

## ðŸš€ Quick Start

Get up and running in under 2 minutes:

### Prerequisites

Make sure you have these installed:
${this.generatePrerequisites(repository, projectType)}

### Installation

**ðŸ“¦ Package Manager (Recommended)**

\`\`\`bash
${this.generateInstallCommand(repository, projectType)}
\`\`\`

**ðŸ”§ From Source**

\`\`\`bash
# Clone the repository
git clone ${repoUrl}.git
cd ${repository.name}

# Install dependencies
${this.generateDependencyInstall(repository, projectType)}

# Start development
${this.generateStartCommand(repository, projectType)}
\`\`\`

### Usage

${this.generateUsageExample(repository, projectType)}

## ðŸ“š Documentation

| ðŸ“– Guide | ðŸ”— Link | ðŸ“ Description |
|----------|---------|----------------|
| **Getting Started** | [View Guide](${repoUrl}#getting-started) | Complete setup and basic usage |
| **API Reference** | [View Docs](${repoUrl}#api) | Detailed API documentation |
| **Examples** | [View Examples](${repoUrl}/tree/main/examples) | Real-world implementation examples |
| **FAQ** | [View FAQ](${repoUrl}#faq) | Common questions and answers |

## ðŸ—ï¸ Architecture

${this.generateArchitectureSection(repository, projectType)}

## ðŸ¤ Contributing

We â¤ï¸ contributions! Here's how you can help make ${repository.name} even better:

| ðŸŽ¯ Ways to Contribute |
|-----------------------|
| ðŸ› **Report bugs** via [Issues](${repoUrl}/issues) |
| ðŸ’¡ **Suggest features** via [Discussions](${repoUrl}/discussions) |
| ðŸ“ **Improve docs** via [Pull Requests](${repoUrl}/pulls) |
| ðŸ”§ **Submit code** via [Pull Requests](${repoUrl}/pulls) |

### Development Setup

\`\`\`bash
# Fork and clone the repo
git clone ${repoUrl.replace('github.com/', 'github.com/YOUR-USERNAME/')}.git

# Create a feature branch
git checkout -b feature/amazing-feature

# Make your changes and commit
git commit -m "Add amazing feature"

# Push and create a PR
git push origin feature/amazing-feature
\`\`\`

Read our [Contributing Guide](${repoUrl}/blob/main/CONTRIBUTING.md) for more details.

## ðŸŒŸ Stargazers

[![Stargazers repo roster for @${repository.owner}/${repository.name}](https://reporoster.com/stars/${repository.owner}/${repository.name})](${repoUrl}/stargazers)

**[â­ Star this repo](${repoUrl}/stargazers) if you find it useful!**

## ðŸ“Š Statistics

![GitHub Stats](https://github-readme-stats.vercel.app/api?username=${repository.owner}&show_icons=true&theme=radical)

## ðŸ“„ License

This project is licensed under the **MIT License** - see the [LICENSE](${repoUrl}/blob/main/LICENSE) file for details.

## ðŸ™ Acknowledgments

**Built with â¤ï¸ by the ${repository.name} team and our amazing contributors**

[![Contributors](https://contrib.rocks/image?repo=${repository.owner}/${repository.name})](${repoUrl}/graphs/contributors)

### Special Thanks

- ðŸŽ¨ **UI/UX Inspiration**: Modern design principles
- ðŸ› ï¸ **Technology Stack**: ${techStack}
- ðŸŒ **Community**: Our amazing users and contributors
- ðŸ’¡ **Open Source**: The incredible open source ecosystem

---

**[ðŸ“§ Contact](mailto:contact@example.com) â€¢ [ðŸ¦ Twitter](https://twitter.com/yourhandle) â€¢ [ðŸ’¼ LinkedIn](https://linkedin.com/company/yourcompany) â€¢ [ðŸŒ Website](https://yourwebsite.com)**

Made with â¤ï¸ and â˜• by the ${repository.name} team

FORMATTING REQUIREMENTS:
- Use ONLY pure markdown syntax - absolutely NO HTML tags
- Include proper spacing and visual hierarchy
- Use tables, badges, and visual elements strategically
- Ensure all links are functional and relevant
- Make content scannable with clear headings and sections
- Use appropriate code formatting with language tags
- Include compelling calls-to-action throughout
- Generate content that renders perfectly on GitHub without any HTML

Generate a README that looks professional, modern, and engaging when rendered on GitHub using pure markdown only!`;
  }

  private findBestLogo(repository: Repository): any[] {
    // Enhanced logo detection with priority order
    const logoPriority = [
      // Exact matches first
      'logo.svg', 'logo.png', 'Logo.svg', 'Logo.png',
      // Brand/identity folders
      'assets/logo.svg', 'assets/logo.png', 'src/assets/logo.svg', 'src/assets/logo.png',
      'public/logo.svg', 'public/logo.png', 'static/logo.svg', 'static/logo.png',
      'images/logo.svg', 'images/logo.png', 'img/logo.svg', 'img/logo.png',
      'brand/logo.svg', 'brand/logo.png', 'branding/logo.svg', 'branding/logo.png',
      // Icon files
      'icon.svg', 'icon.png', 'favicon.svg', 'favicon.png',
      // README images (common practice)
      'readme-logo.svg', 'readme-logo.png', 'header.svg', 'header.png'
    ];

    // First try exact path matches
    for (const logoPath of logoPriority) {
      const exactMatch = repository.files.find(file => 
        file.type === 'file' && file.path === logoPath
      );
      if (exactMatch) return [exactMatch];
    }

    // Then try flexible matching
    const logoFiles = repository.files.filter(file => 
      file.type === 'file' && (
        file.name.toLowerCase().includes('logo') ||
        file.name.toLowerCase().includes('icon') ||
        file.name.toLowerCase().includes('brand') ||
        file.path.toLowerCase().includes('logo') ||
        file.path.toLowerCase().includes('icon') ||
        file.path.toLowerCase().includes('brand')
      ) && (
        file.name.endsWith('.svg') ||
        file.name.endsWith('.png') ||
        file.name.endsWith('.jpg') ||
        file.name.endsWith('.jpeg') ||
        file.name.endsWith('.webp')
      )
    );

    if (logoFiles.length === 0) return [];

    // Prioritize SVG over other formats, and shorter paths
    logoFiles.sort((a, b) => {
      // SVG gets priority
      if (a.name.endsWith('.svg') && !b.name.endsWith('.svg')) return -1;
      if (!a.name.endsWith('.svg') && b.name.endsWith('.svg')) return 1;
      
      // Shorter paths get priority (likely in root or main assets folder)
      return a.path.length - b.path.length;
    });

    return logoFiles;
  }

  private findDemoFiles(repository: Repository): any[] {
    const demoPatterns = [
      'demo.png', 'demo.jpg', 'demo.gif', 'screenshot.png', 'screenshot.jpg',
      'preview.png', 'preview.jpg', 'preview.gif', 'example.png', 'example.jpg',
      'assets/demo.png', 'assets/screenshot.png', 'docs/demo.png', 'docs/screenshot.png',
      'images/demo.png', 'images/screenshot.png', '.github/demo.png', '.github/screenshot.png'
    ];

    return repository.files.filter(file => 
      file.type === 'file' && (
        demoPatterns.some(pattern => file.path.toLowerCase().includes(pattern.toLowerCase())) ||
        (file.path.toLowerCase().includes('demo') && (file.name.endsWith('.png') || file.name.endsWith('.jpg') || file.name.endsWith('.gif'))) ||
        (file.path.toLowerCase().includes('screenshot') && (file.name.endsWith('.png') || file.name.endsWith('.jpg'))) ||
        (file.path.toLowerCase().includes('preview') && (file.name.endsWith('.png') || file.name.endsWith('.jpg')))
      )
    );
  }

  private generateTagline(repository: Repository, projectType: string): string {
    const taglines = {
      'Frontend Application': `ðŸš€ Next-generation ${repository.language} application with modern UI/UX`,
      'Backend API': `âš¡ High-performance, scalable ${repository.language} API built for production`,
      'Full-Stack Application': `ðŸ”¥ Complete full-stack solution powered by ${repository.language}`,
      'CLI Tool': `ðŸ› ï¸ Powerful command-line tool that supercharges your workflow`,
      'Library': `ðŸ“š Essential ${repository.language} library for modern developers`,
      'Framework': `ðŸ—ï¸ Flexible ${repository.language} framework for rapid development`,
      'Python Application': 'ðŸ Powerful Python application with enterprise-grade features',
      'JavaScript/Node.js Project': 'âš¡ Modern JavaScript/Node.js solution for the web',
      'Rust Application': 'ðŸ¦€ Blazingly fast and memory-safe Rust application',
      'Go Application': 'ðŸš€ Lightning-fast Go application built for scale',
      'default': `ðŸ’Ž ${repository.description || `Professional ${repository.language} project built with care`}`
    };

    return taglines[projectType] || taglines.default;
  }

  private generateKeyBenefits(repository: Repository, projectType: string): string {
    const benefits = {
      'Frontend Application': `
ðŸŽ¨ **Beautiful & Responsive** - Stunning UI that works flawlessly across all devices
âš¡ **Lightning Fast** - Optimized performance with modern build tools and techniques
ðŸ”§ **Developer Experience** - Hot reload, TypeScript support, and excellent tooling
ðŸŽ¯ **Production Ready** - Battle-tested architecture used by thousands of developers`,

      'Backend API': `
ðŸš€ **High Performance** - Built for scale with efficient algorithms and caching
ðŸ”’ **Enterprise Security** - Industry-standard authentication and data protection
ðŸ“Š **Real-time Analytics** - Monitor performance and usage with built-in metrics
ðŸ”„ **API-First Design** - RESTful endpoints with comprehensive documentation`,

      'CLI Tool': `
âš¡ **Blazing Fast** - Optimized for speed and efficiency in your daily workflow
ðŸŽ¯ **Intuitive Commands** - Simple, memorable commands that just make sense
ðŸ”§ **Highly Configurable** - Customize every aspect to fit your specific needs
ðŸ“¦ **Zero Dependencies** - Lightweight binary that runs anywhere`,

      'default': `
âœ¨ **Production Ready** - Built with industry best practices and modern standards
ðŸš€ **Developer Friendly** - Excellent documentation and developer experience
ðŸ”’ **Reliable & Secure** - Thoroughly tested and security-focused architecture
ðŸŒ **Community Driven** - Backed by an active community of contributors`
    };

    return benefits[projectType] || benefits.default;
  }

  private generateCoreFeatures(projectType: string): string {
    const features = {
      'Frontend Application': `
- ðŸŽ¨ Modern, responsive design
- âš¡ Lightning-fast performance
- ðŸ“± Mobile-first approach
- ðŸ”§ Easy customization`,

      'Backend API': `
- ðŸ”„ RESTful API endpoints
- ðŸ”’ JWT authentication
- ðŸ“Š Built-in analytics
- ðŸš€ Auto-scaling support`,

      'CLI Tool': `
- âš¡ Fast command execution
- ðŸŽ¯ Intuitive interface
- ðŸ“ File system integration
- ðŸ”§ Plugin architecture`,

      'default': `
- âœ¨ Clean, modern architecture
- ðŸš€ High performance
- ðŸ”§ Easy to extend
- ðŸ“š Well documented`
    };

    return features[projectType] || features.default;
  }

  private generateAdvancedFeatures(projectType: string): string {
    const features = {
      'Frontend Application': `
- ðŸ”„ Real-time updates
- ðŸŽ­ Theme customization
- ðŸ“Š Analytics integration
- ðŸŒ i18n support`,

      'Backend API': `
- ðŸ“ˆ Rate limiting
- ðŸ” Advanced filtering
- ðŸ“ Auto-documentation
- ðŸ”„ Webhook support`,

      'CLI Tool': `
- ðŸ”Œ Plugin system
- ðŸ“‹ Batch operations
- ðŸŽ¨ Customizable output
- ðŸ’¾ Configuration management`,

      'default': `
- ðŸ”Œ Plugin system
- ðŸŽ¨ Theming support
- ðŸ“Š Monitoring tools
- ðŸ”„ Auto-updates`
    };

    return features[projectType] || features.default;
  }

  private generatePrerequisites(repository: Repository, projectType: string): string {
    if (repository.files.some(f => f.name === 'package.json')) {
      return `
- **Node.js** (v18 or higher) - [Download here](https://nodejs.org/)
- **npm** or **yarn** - Package manager
- **Git** - Version control`;
    }
    
    if (repository.files.some(f => f.name === 'requirements.txt')) {
      return `
- **Python** (3.8 or higher) - [Download here](https://python.org/)
- **pip** - Python package manager
- **Git** - Version control`;
    }

    if (repository.files.some(f => f.name === 'Cargo.toml')) {
      return `
- **Rust** (latest stable) - [Install here](https://rustup.rs/)
- **Cargo** - Rust package manager (included with Rust)
- **Git** - Version control`;
    }

    return `
- **Git** - Version control system
- **Your favorite code editor** - VS Code recommended
- **Terminal** - Command line interface`;
  }

  private generateInstallCommand(repository: Repository, projectType: string): string {
    if (repository.files.some(f => f.name === 'package.json')) {
      const pkg = repository.files.find(f => f.name === 'package.json');
      if (pkg?.content) {
        try {
          const parsed = JSON.parse(pkg.content);
          if (parsed.name) {
            return `npm install ${parsed.name}\n# or\nyarn add ${parsed.name}`;
          }
        } catch (e) {
          // Ignore parse errors
        }
      }
      return `npm install ${repository.name}\n# or\nyarn add ${repository.name}`;
    }

    if (repository.files.some(f => f.name === 'requirements.txt')) {
      return `pip install ${repository.name}`;
    }

    if (repository.files.some(f => f.name === 'Cargo.toml')) {
      return `cargo install ${repository.name}`;
    }

    return `# Installation instructions will be added based on your project structure`;
  }

  private generateDependencyInstall(repository: Repository, projectType: string): string {
    if (repository.files.some(f => f.name === 'package.json')) {
      return 'npm install';
    }
    if (repository.files.some(f => f.name === 'requirements.txt')) {
      return 'pip install -r requirements.txt';
    }
    if (repository.files.some(f => f.name === 'Cargo.toml')) {
      return 'cargo build';
    }
    return '# Install dependencies based on your project';
  }

  private generateStartCommand(repository: Repository, projectType: string): string {
    if (repository.files.some(f => f.name === 'package.json')) {
      return 'npm run dev';
    }
    if (repository.files.some(f => f.name === 'requirements.txt')) {
      return 'python main.py';
    }
    if (repository.files.some(f => f.name === 'Cargo.toml')) {
      return 'cargo run';
    }
    return '# Start your application';
  }

  private generateUsageExample(repository: Repository, projectType: string): string {
    if (projectType === 'Frontend Application') {
      return `
\`\`\`bash
# Start the development server
npm run dev

# Open your browser to http://localhost:3000
# Start building amazing UIs! ðŸŽ¨
\`\`\``;
    }

    if (projectType === 'Backend API') {
      return `
\`\`\`bash
# Start the API server
npm start

# Test your first endpoint
curl http://localhost:8000/api/health
\`\`\``;
    }

    if (projectType === 'CLI Tool') {
      return `
\`\`\`bash
# Run your first command
${repository.name} --help

# Try the main functionality
${repository.name} init my-project
\`\`\``;
    }

    return `
\`\`\`bash
# Basic usage example
${repository.name} --version

# Get help
${repository.name} --help
\`\`\``;
  }

  private generateArchitectureSection(repository: Repository, projectType: string): string {
    return `
<div align="center">

\`\`\`mermaid
graph TD
    A[User Interface] --> B[Core Logic]
    B --> C[Data Layer]
    C --> D[External APIs]
    
    style A fill:#e1f5fe
    style B fill:#f3e5f5
    style C fill:#e8f5e8
    style D fill:#fff3e0
\`\`\`

</div>

**Built with modern architecture principles:**
- ðŸ—ï¸ **Modular Design** - Clean separation of concerns
- ðŸ”„ **Event-Driven** - Reactive and responsive architecture
- ðŸ“¦ **Microservices Ready** - Scalable and maintainable
- ðŸ§ª **Test-Driven** - Comprehensive test coverage`;
  }

  private detectTechStack(repository: Repository): string {
    const techStack: string[] = [];
    
    // Check package.json for JavaScript/Node.js
    const packageJson = repository.files.find(f => f.name === 'package.json');
    if (packageJson?.content) {
      try {
        const pkg = JSON.parse(packageJson.content);
        if (pkg.dependencies || pkg.devDependencies) {
          const deps = { ...pkg.dependencies, ...pkg.devDependencies };
          
          // Frontend frameworks
          if (deps.react) techStack.push('React');
          if (deps.vue) techStack.push('Vue.js');
          if (deps.angular) techStack.push('Angular');
          if (deps.svelte) techStack.push('Svelte');
          
          // Meta frameworks
          if (deps.next) techStack.push('Next.js');
          if (deps.nuxt) techStack.push('Nuxt.js');
          if (deps.gatsby) techStack.push('Gatsby');
          
          // Backend frameworks
          if (deps.express) techStack.push('Express.js');
          if (deps.fastify) techStack.push('Fastify');
          if (deps.koa) techStack.push('Koa');
          if (deps.nestjs) techStack.push('NestJS');
          
          // Languages and tools
          if (deps.typescript) techStack.push('TypeScript');
          if (deps.tailwindcss) techStack.push('Tailwind CSS');
          if (deps.sass || deps.scss) techStack.push('Sass');
          if (deps.webpack) techStack.push('Webpack');
          if (deps.vite) techStack.push('Vite');
          
          // Databases
          if (deps.mongoose) techStack.push('MongoDB');
          if (deps.mysql || deps.mysql2) techStack.push('MySQL');
          if (deps.pg) techStack.push('PostgreSQL');
          if (deps.sqlite3) techStack.push('SQLite');
        }
      } catch (e) {
        // Ignore JSON parse errors
      }
    }
    
    // Check for other languages and frameworks
    const fileNames = repository.files.map(f => f.name.toLowerCase());
    
    if (fileNames.includes('requirements.txt') || fileNames.includes('setup.py') || fileNames.includes('pyproject.toml')) {
      techStack.push('Python');
    }
    if (fileNames.includes('cargo.toml')) {
      techStack.push('Rust');
    }
    if (fileNames.includes('go.mod') || fileNames.includes('go.sum')) {
      techStack.push('Go');
    }
    if (fileNames.includes('pom.xml') || fileNames.includes('build.gradle')) {
      techStack.push('Java');
    }
    if (fileNames.includes('gemfile')) {
      techStack.push('Ruby');
    }
    if (fileNames.includes('composer.json')) {
      techStack.push('PHP');
    }
    if (fileNames.includes('dockerfile') || fileNames.includes('docker-compose.yml')) {
      techStack.push('Docker');
    }
    
    return techStack.length > 0 ? techStack.join(', ') : repository.language || 'Multiple Technologies';
  }

  private detectProjectType(repository: Repository): string {
    const files = repository.files.map(f => f.name.toLowerCase());
    
    // Check package.json for specific project types
    if (files.includes('package.json')) {
      const packageJson = repository.files.find(f => f.name === 'package.json');
      if (packageJson?.content) {
        try {
          const pkg = JSON.parse(packageJson.content);
          const deps = { ...pkg.dependencies, ...pkg.devDependencies };
          
          // Frontend applications
          if (deps.react || deps.vue || deps.angular || deps.svelte) {
            return 'Frontend Application';
          }
          
          // Full-stack frameworks
          if (deps.next || deps.nuxt || deps.gatsby) {
            return 'Full-Stack Application';
          }
          
          // Backend APIs
          if (deps.express || deps.fastify || deps.koa || deps.nestjs) {
            return 'Backend API';
          }
          
          // CLI tools
          if (pkg.bin || deps.commander || deps.yargs || deps.inquirer) {
            return 'CLI Tool';
          }
          
          // Libraries
          if (pkg.main && !deps.express && !deps.react) {
            return 'Library';
          }
          
        } catch (e) {
          // Ignore JSON parse errors
        }
      }
      return 'JavaScript/Node.js Project';
    }
    
    // Other language detection
    if (files.includes('requirements.txt') || files.includes('setup.py')) {
      return 'Python Application';
    }
    if (files.includes('cargo.toml')) {
      return 'Rust Application';
    }
    if (files.includes('go.mod')) {
      return 'Go Application';
    }
    if (files.includes('pom.xml')) {
      return 'Java Application';
    }
    if (files.includes('gemfile')) {
      return 'Ruby Application';
    }
    if (files.includes('composer.json')) {
      return 'PHP Application';
    }
    
    return 'Software Project';
  }

  private cleanupGeneratedContent(content: string): string {
    // Remove any markdown code block wrappers if present
    let cleaned = content.replace(/^```markdown\s*\n/, '').replace(/\n```$/, '');
    
    // Remove any extra whitespace at the beginning and end
    cleaned = cleaned.trim();
    
    // Ensure proper spacing between sections
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
    
    // Fix any malformed headers
    cleaned = cleaned.replace(/^#{1,6}\s*/gm, (match) => match.trim() + ' ');
    
    return cleaned;
  }

  private extractSections(content: string): string[] {
    const sections: string[] = [];
    const lines = content.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (trimmedLine.startsWith('# ') || trimmedLine.startsWith('## ')) {
        const sectionName = trimmedLine.replace(/^#+\s*/, '').replace(/[^\w\s]/g, '').trim();
        if (sectionName) {
          sections.push(sectionName);
        }
      }
    }
    
    return sections;
  }
}